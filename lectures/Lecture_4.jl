#=
# ЛЕКЦИЯ 4

## 1. Система типов Julia

- Иерархия типов
Во главе всей иерархии типов - тип Any

Тип Number - стоит во главе всех числовых типов (и является подтипом Any)
У типа Number есть всего 2 подтипа: 
    Complex
    Real

Подтипами типа Real, например, являются типы:
    AbstractFloat # - тип всех чисел с плавающей точкой  
    AbstractIrrational # - тип всех иррациональных чисел
    Integer # - тип всех целых чисел
    Rational # - тип всех рациональных чисел

Подтипами типа Integer, например, являются типы:
    Bool # - логический тип
    Signed # - знаковые целые
    Unsigned # - беззнаковые целые

Подтипами типа Signed, наприме, являются типы:
    BigInt # - "длинные" целые со знаком
    Int128 # - 128 битные целые со знаком
    Int64  # - 64 битные целые со знаком - синоним Int
    Int32  # - 32 битные целые со знаком
    Int16  # - 16 битные целые со знаком
    Int8   # - 8 битные целые со знаком

Типы
    BigInt, Int128, Int64, Int32, Int16, Int8

- это примеры КОНКРЕНТНЫХ типов.

Все остальные рассмотренные типы были АБСТРАКТНЫМИ.

Конкретные типы - это типы, стоящие на самой нижней иерархической ступеньке.
Все остальные типы - это абстрактные типы.

Любой объект (переменная или значение) имеет какой-либо конкретный тип.
Создать объект абстрактного типа невозможно, т.к. абстрактный тип не предполагает 
наличия каких-либо конкретных данных, абстрактные типы служат исключительно для создания
иерархии типов.


Некоторые из абстрактных типов являются параметрическими. 
Например, параметрическим является абстрактный тип Complex:

    Complex{Float64} # - это уже получится конктетный тип (т.к. в данном случае параметр - есть конкретный тип Float64)
    Complex{Real} # - а это попрежнему абстрактный тип (т.к. в данном случае параметр - есть абстрактный тип)


Конкретные типы не могут иметь подтипов (т.к. они стоят на САМОЙ НИЖНЕЙ иерархической ступеньке).

Для выяснение соподчиненности типов имеются встроенные функции:

    supertype(TypeName) # - возвращает родительский тип для типа TypeName
    subtypes(TypeName) # - возвращает вектор (список) дочерних типов для типа TypeName

Кроме того, имеется операция <: (>:), например:

    Int64 <: Integer # - вернёт true
    Int64 >: Integer # - вернёт false
    Int64 <: Real # - тоже вернёт true


Система типов Julia является расширяемой, т.е. в иерархию изначально существующих (встроенных) типов.
Новые типы добавляемые в систему типов, называются пользовательскими.

Пользовательские типы могут быть как конкретными (определяются на основе конструкции struct), 
так и абстрактными (abstract type), в том числе и параметрическими.

Все стандартные контейнерные типы данных, такие как Vector, или Matrix (оба этих типа являются просто частным 
случаем типа Array) являются параметрическими. Например, определять вектор типа Int (т.е. Int64) надо так:

    Vector{Int}

Но, ВНИМАНИЕ, определение:
    Vector{Integer}
- это было бы неправильным определением типа, правильно в этом случае было бы так:
    Vector{<:Integer}
На это правило есть объективные причины.

## 2. Обобщенный подход к программированию

Подход к программированию (парадигма программирования), согласно которому описание данных и алгоритмов (функций)
делается так, что бы это описание было применимо ни к какому-то одному конкретному типу данных 
(или к набору конкретных типов данных), а было бы применимо к различным типам данных, причем для этого
не требовалось бы вносить никакие изменение в это описание.

Обобщенное описание типов данных сводится к определению абстрактных типов, в том числе к определению параметрических 
типов. Но к этому мы ещё вернёмся.

Рассмотрим пример проектирвания обобщённой функции.

Пусть требуется написать функцию, возвращающую определитель матрица 2*2.
Если элементы матрицы имеют тип Int, то определение функция может иметь вид:
=#
function det(A::Matrix{Int})
    @assert size(A) == (2,2) # встроенная функция size возвращает кортеж из размеров массива
    # - это проверка условия, что матрица размера 2*2 
    # (в противном случае произойдет прерывание функции и вывод сообщения об ошибке)
    return A[1,1]*A[2,2]-A[1,2]*A[2,1]
end

#= 
А если теперь понадобилось бы вычислить определитель матрицы, элементы которой имеют тип Float64,
то понадобилось бы новое определение функции:
=#
function det(A::Matrix{Float})
    @assert size(A) == (2,2) 
    # - это проверка условия, что матрица размера 2*2 
    # (в противном случае произойдет прерывание функции и вывод сообщения об ошибке)
    return A[1,1]*A[2,2]-A[1,2]*A[2,1]
end

#=
Как видим, тело новой функции осталось прежним, изменилась только аннотация типа в заголовке функции.

При этом, если понадобится рассмотреть матрицы каких-либо еще других типов, например, 
Rational{Int} или Comple{Float64}, то понадобятся и новые определения функции. При этом по внешнему виду
тело функции будет оставаться всё тем же.

Для того, что бы не плодить большое число описаний этой функции, её описание можно было бы сделать
обобщенным (generic). 
Для этого можно было бы просто отказаться от аннотации типа её аргумента:
=#
function det(A) # det(A::Any) - это то же самое
    @assert size(A) == (2,2)
    A[1,1]*A[2,2]-A[1,2]*A[2,1] # слово return здесь не обязательно
end

#=
Если интерфейс фактического тип параметра A включает опреации `*`, `-`, то данная функция может быть вычислена.
Например:
=#
> det([1 2;3 4]) # -> -2 (тип Int64)
> det([1.0 2.0; 3.0 4.0])  # -> -2.0 (тип Float64)

#=
Но в следующем случае:
=#
> det(["1" "2"; "3" "4"])
#=
произойдет ошибка, вызванная тем, что опрерация `-` не определена для типа String 
(операция `*` - в Julia это операция конкатенации строк, так что резултатом A[1,1]*A[2,2] будет "14", 
а результатом A[1,2]*A[2,1] будет "23")
=#

#=
Если тип аргумента обобщенной функции аннотирован как Any (в этом случае можно сказать, что тип не аннотирован),
то из заголовка такой функции не ясно, каким интерфейсом этот аргумент должен обладать.
В этом случае говорят, что требуемый интерфейс явно не описан.
Такую типизацию аргументов функции, без явных требований к интерфейсу, принято называть "утиной" типизацией. 

Такое название происходит от образного выражения "если нечто ходит как утка и крякает как утка, то это нечто 
и есть утка".

Применительно к нашему примеру, если для фактического типа аргумента определены операции `*` и `-`, то этот 
аргумент является допустимым (является той самой "уткой").

Однако мы могли бы явно описать требования к интерфейсу аргументу нашей функции, определив его тип так:
=#
function det(A::Vector{<:Number}) # det(A::Any) - это то же самое
    @assert size(A) == (2,2)
    A[1,1]*A[2,2]-A[1,2]*A[2,1] # слово return здесь не обязательно
end
#=
Здесь мы явно указали, что элементами матрицы должны быть числа, а для любых чисел должны быть определены
операции `*` и `-`
=#

#=
С практической точки зрения разница между утиной типизацией и явным указанием типа аргумена Matrix{:<Number}
не столь уж велика.
Так в первом случае при вызове
=#
> det(["1" "2"; "3" "4"])
#=
ошибка произойдет при попытке скомпилировать выражение A[1,1]*A[2,2]-A[1,2]*A[2,1]

А во втором случае ошибка произойдет при попытке скомпилировать выражение det(["1" "2"; "3" "4"]).

Иногда, правда второй случай более предпочтителен в виду того, что в противном случае ошибка при попытке 
компиляции может происходить где-то достаточно "глубоко" в цепочке вызовов различных функций, и это может 
несколько затруднять отладку.

С другой стороны, иногда, при использовании сложных типов, их полное описаение может оказаться довольно
громоздким, и  в таких случаях его часто упрощают (делают более общим, чем требуется) либо вообще оставляют
соответствующий аргумент функции без аннотации.

### Замечание

Вместо описания
=#
det(A::Matrix{<:Number}) = A[1,1]*A[2,2]-A[1,2]*A[2,1]
#=
В языке Julia возможно эквивалентное опивание:
=#
det(A::Matrix{T}) where {T <:Number} = A[1,1]*A[2,2]-A[1,2]*A[2,1]
#=
Здесь разница лишь в том, что теперь в теле функции есть возможность использовать тип T.
В рассмотренном примере нам это в общем-то ни к чему, поэтому рассморим другой простой пример.
Пусть требуется написать обобщенную функцию, суммирующую элементы вектора
=#
function sum(vector::Vector{T}) where{T<:Number}
    s=T(0) 
    # здесь 0 типа Int64 преобразуется к нулю фактического типа T 
    #(иначе переменная s будет иметь не стабильный тип, что плохо, с точки зрения генерации эффетивного кода 
    # компилятором Julia)
    for a in vector
        s =+ a
    end
    return s
end
#=
В противном случае пришлось бы делать так:
=# 
function sum(vector::Vector{<:Number})
    s=eltype(vector)(0) 
    # встроенная функция eltype(vector) возвращает тип элементов данного массива vector
    for a in vector
        s =+ a
    end
    return s
end

#=
## 3. Пользовательские типы данных

Конкретные (не абстрактные) пользовательские типы проектируются на основе конструкции struct.

С помощью этой конструкции определяются составные типы данных, состоящие из некоторого количества полей 
(формально число полей в структуре может быть любым, в том числе и равным 0).
Например:
=#

struct NameType
    a::T1
    b::T2
end

#=
- это определение нового типа данных с именем NameType (имя типа может быть практически любым, 
но следует придерживаться указанного стиля именования).
Поля этого составного типа данных имеют типы T1, Т2 соответственно.
Типы полей могут быть любыми, но желательно, чтобы они были конкретными, а не абстрактными, что обеспечит
возможность компилятору Julia генерировать более эффективный код. 

Что бы создать объет данного типа нужно воспользоваться соответствующим конструктором типа. Конструктор типа 
- это специальная функция, которая создает объет соответствующего типа и возвращает ссылку на этот объект 
(именно - ссылку, а не сам объект). Имя конструктрора всегда совпадает с именем типа 
(так же как и для встроенных типов).

Если конструктор не был специально определен, то всегда имеется конструктор по умолчанию.
В данном случае конструктором по умолчанию можно было бы воспользоваться так:
=#
> x=NameType(0,0)
#=
Тогда, при условии, что значение 0 может быть приведено к типам T1 и T2,
поле `a` объекта `x` получит значение T1(0), а поле `b` - значение T2(0).

Получить значения этих полей можно, используя составное имя, так:
=#
> x.a 
> x.b
#=
Но изменить значения этих аолей не получится, например:
=#
> x.a = T1(1)
#=
Изменять значения полей структуры в данном случае нельзя, потому что структура была объявлена (не явно), 
как неизменяемая (с точки зрения возможности компиляции в эффективный код неизменяемые структуры 
предпочтительнее изменяемых).
Для создания изменяемых структур используется специальное слово `mutable`, например:
=#
mutable struct NameType2
    a::Int
    b::Int
end

> y=NameType2(0,0)

> y.a=1 # такое присваивание возможно

> y=NameType1(0,0)

> y.a=1 # это присваивание не возможно

#=
Перейдем теперь к более содержательным примерам.

### Пример 1

Пусть Робот на ходится где-то на поле между внутренними перегородками или прямолинейной формы или в форме 
прямоугольников (внутренние перегородки не касаются друг друга и внешней перегородки).

И пусть требуется сначала переместить Робота в один из углов поля, затем выполнить некоторые действия 
и вернуться в исходный угол, а затем от туда вернуться в исходное положение.

С такой задачей мы уже встречались ни один раз. Вот как можно унифицировать эту задачу, спроектировав специальный
тип данных, в котором будет представлен путь возвращения Робота из стартового угла в исходное положение. 
=#
struct BackPath
    sides::NTuple{2,HorizonSide}
    path::Vector{Int}
end

# Определим теперь специальный конструктор для этого типа (конструктор по умочанию нас не устроит):

function BackPath(robot, sides::NTuple{2,HorizonSide}=(Sud,West))
    local path=Int[]
    while !isborder(robot,sides[1]) || !isborder(robot,sides[2])
        for s in sides 
            push!(path, movements!(robot,s))
        end
    end
    return new(reverse(inverse.(sides)),path)
end

#=
При определении конструктора всегда используется встроенная фунуция `new`, у которой должно быть 
столько же аргументов, сколько имеется полей в структуре, и в результате выполнения котрой будет создан
объект соответствующего типа, полям которого будут присвоены значения аргументов функции new: первому полю
присваивается значение первого аргумента, второму полу - значение вторго аргумента, и т.д.  по порядку.

Так же для данного типа определим ещё следующую функцию, с помощью которой Робот может быть перемещен
в исходное положение путем прохождения ранее пройденного пути в обратном направлении:
=#
function back!(robot, backpath::BackPath)
    i=1
    for n in backpath.path
        movements!(robot, backpath.sides[i])
        i = i%2 + 1
    end
end

#=
Общая схема решения задач с использованием объекта типа BackPath:
=#
#УТВ: Робот в некоторой начальной клетке среди прямоугольных перегородок
    back_path = BackPath(r)
    #УТВ: Робот - в Ю-З углу
    #..... требуемые действия
    #УТВ: Робот снова находится в Ю-З углу
    back!(r, back_path)
    #УТВ: Робот - в исходном положении


#=
### Пример 2

Для решения некоторых задач может понадобится знать Декартовы координаты положения Робота относительно некоторого
"начального" его положения.
Для этого спроектируем сначала следующий тип данных на основе  изменяемой (мутабельной) структуры:
=#
mutable struct Coord
    x::Int
    y::Int
    Coord() = new(0,0) # - такой конструктор определен для удобства использования
    Coord(x::Int,y::Int) = new(x,y)
end
#=
Конструкторов может быть несколько, и конструкторы можно определять внутри конструкции struct (все остальные функции
для типа) должны определяться как внешние функции, т.е. за пределами конструкции struct.

Так же для данного типа определим ещё слеующие две функции. Первая из них `move!` изменяет значение текущих координат
при ВООБРАЖАЕМОМ перемещении Робота в заданном направлении на 1 шаг.

Вторая `get_coord` - возвращает кортеж с текущими координатами.
=#
function move!(coord::Coord, side::HorizonSide)
    if side==Nord
        coord.y += 1
    elseif side==Sud
        coord.y -= 1
    elseif side==Ost
        coord.x += 1
    else #if side==West
        coord.x -= 1
    end
end

get_coord(coord::Coord) = (coord.x, coord.y)

#=
Наличие функции `get_coord` избавляет от необходимости помнить (знать) внутренне устройство объекта типа 
`BackPath`.

Эти две функции `move!` и `get_coord` составляют интерфейс типа BackPath.

Взаимодействие с объектами данного типа только посредством его интерфейса, 
исключая прямое взаимодействие с полями объекта, есть соблюдение принципа ИНКАПСУЛЯЦИИ
данных (принцип сокрытия данных в объете).

Это очень важный принцип и ему слеует следовать.

Например, использовать разработанный тип можно так:
=#
> coord=Coord()
> move!(coords,Nord)
> get_coords(coords) # -> (0,1)

#=
## 4. Иерархия пользовательских типов

Для того чтобы получить Робота, который при своих перемещениях будет отслеживать свои координаты
потребуется  "скрестить" два типа:

Robot + Coord

T.к. оба типа являются конкретными, то сделать это можно следующими способами: путем композиции типов или путем
проектирования дополнительного абстрактного типа с последующим наследованием от него.

### Композиция типов

Следующая структура представляет собой композицию конкретного типа Robot и конкретного типа Coord:
=# 
struct XYRobot
    robot::Robot
    coord::Coord
end

#=
остается только определить интерфейс для этого типа
(чем мы и займемся в следующий раз)
=#

